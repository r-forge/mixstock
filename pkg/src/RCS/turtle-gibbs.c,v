head	1.13;
access;
symbols;
locks
	ben:1.13; strict;
comment	@ * @;


1.13
date	2002.03.13.14.34.48;	author ben;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.27.21.33.39;	author ben;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.25.15.21.38;	author toshi;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.07.16.18.18;	author toshi;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.21.42.49;	author toshi;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.18.15.29;	author toshi;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.18.12.29;	author toshi;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.17.51.09;	author toshi;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.17.28.03;	author toshi;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.17.22.00;	author toshi;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.16.59.09;	author toshi;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.16.39.48;	author toshi;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.22.12.36.50;	author ben;	state Exp;
branches;
next	;


desc
@Gibbs sampler for stock analysis with mtDNA haplotypes
@


1.13
log
@took out randlib, vecutils dependencies; changed MXNCAT to MAXNCAT;
changed ihrmat from long to int; took out "genmul_kluge" (rounding
now done within genmul, in newrand.c); took out vecutils dependencies;
comment spacing; lots of debugging Rprintf's, now commented out;
@
text
@#include <stdio.h>
#include <math.h>
#include <string.h>
/* #include "randlib.h" */
#include "utils.h"
#include "R_ext/PrtUtil.h"

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define MAXNCAT 100L
#define MAXHAP  MAXNCAT
#define MAXROOK MAXNCAT

typedef float  frvec[MAXROOK];
typedef float  fhvec[MAXHAP];
typedef int    irvec[MAXROOK];
typedef int    ihvec[MAXHAP];
typedef float  fhrmat[MAXHAP][MAXROOK];
typedef float  frhmat[MAXROOK][MAXHAP];
typedef int    ihrmat[MAXHAP][MAXROOK];
typedef int    irhmat[MAXROOK][MAXHAP];

/* 25 July 2000: revamp memory allocation etc. to avoid double-allocating:
 * single, etc. etc. */
extern void frdirich(float *prob, int ncat, float *results);
extern void fgenmul(int n, float *p, int ncat, int *ix, int round);

void gibbswrap(int *H, int *R, double *a, int *startiter, int *maxiter,
	       int * poolsamp, int * rooksamp, int *startfval, int *thin,
	       double *dprior, double *results,
	       int *outfile,
 	       char **outfn,
/* 	       char **randphrase, */
	       int *ranseed,
	       int *rptiter,
               int *contrun,
               double * startcontrib,
               double * startrookfreq);
	  
int gibbs(int H, int R, float a, long startiter, long maxiter,
	  int * poolsamp, irhmat rooksamp, int startfval, int thin,
	  frvec fprior, double *resmat,
	  int outfile, char *outfn, int from_R, int rptiter,
          int contrun, frvec scontrib, frhmat srookfreq);

void BUGSout(double * g, int H, int R, long tot, char *fn);

int main(int argc, char ** argv) {
  int H, R;
  float a;
  long startiter, maxiter;
  int rptiter=1000;
  int poolsamp[MAXHAP];
  irhmat rooksamp;
  int startfval;
  int thin;
  frvec fprior,scontrib;
  frhmat srookfreq;
  double *resmat;

  int h,r;

  static char phrase[100];  /* random-number seed */
  static long is1,is2;

  /* no sanity checks: should check maxiter<startiter, (maxiter-startiter)/thin is
   * an integer, startfval <= R, etc., etc. */
  printf("Enter phrase (no spaces) for PRNG seed:\n");
  scanf("%s",phrase);
  /* phrtsd(phrase,&is1,&is2); */
  /* setall(is1,is2); */
  printf("Enter # haps, # rooks:\n");
  scanf("%d %d",&H,&R);
  /*   rooksamp=i2matrix(R,H); */
  printf("Enter hap samples from pooled pop (%d)\n",H);
  for (h=0; h<H; h++)
    scanf("%d",poolsamp+h);
  for (r=0; r<R; r++) {
    printf("Hap samples from rookery %d:\n",r+1);
    for (h=0; h<H; h++)
      scanf("%d",rooksamp[r]+h);
  }
  printf("startfval (0 for equal contribs, 1<=n<=R for biased contrib):\n");
  scanf("%d",&startfval);
  printf("burn-in, total, thinning factor:\n");
  scanf("%ld %ld %d",&startiter,&maxiter,&thin);
  a=1.0;
  gibbs(H,R,a,startiter,maxiter,poolsamp,rooksamp,startfval,thin,fprior,resmat,
	1,"turtle-gibbs",FALSE,rptiter,FALSE,scontrib,srookfreq);
  exit(0);
}

void gibbswrap(int *H, int *R, double *a, int *startiter, int *maxiter,
	       int * poolsamp, int * rooksamp, int *startfval, int *thin,
	       double *dprior, double *results,
	       int  *outfile,
 	       char **outfn,
/* 	       char **randphrase, */
	       int *ranseed,
	       int *rptiter,
               int *contrun,
               double * startcontrib,
               double * startrookfreq) {

  /* get everything in double format from R */

  frvec fprior;
  frvec scontrib;
  irhmat rookmat;
  frhmat srookfreq;
  int h,r;
  int npts,nvars;
  static long is1,is2=234234;
  /* char *outfn="gibbsout"; */

  /* Rprintf("%d %d %d %f %f\n",*ranseed,*rptiter,*contrun,startcontrib[0],startrookfreq[0]); */
  /* seed random-number generator */
  /*   phrtsd(*randphrase,&is1,i&s2); */
  /* is1 = (long)ranseed; */
  /* setall(is1,is2); */

  /*   Rprintf("PRNG seed: (%s) %ld %ld\n",*randphrase,is1,is2); */
  /*  if (*outfile==1) {
   * Rprintf("Printing output to file %s.{BOT,FRQ}\n",outfn[0]);
   *   }
   */

    for (r=0; r<(*R); r++) {
      scontrib[r] = (float)startcontrib[r];
      for (h=0; h<(*H); h++)  {
        rookmat[r][h] = rooksamp[(*H)*r+h];
        srookfreq[r][h] = (float)startrookfreq[(*H)*r+h];
      }
    }

  /*   if (dprior[0]<0) */
  /*     fprior=NULL; */
  /*   else { */
  /*     Rprintf("allocating fprior\n"); */
  /*     fprior=farray(*R); */
    for (r=0; r<(*R); r++)
      fprior[r]=(float)dprior[r];
    /*   } */

  gibbs(*H,*R,(float)*a,(long)*startiter,(long)*maxiter,
	poolsamp,rookmat,*startfval,*thin,fprior,results,
	*outfile,*outfn,TRUE,*rptiter,*contrun,
	scontrib,srookfreq);
  npts =(*maxiter-*startiter)/(*thin);
  nvars = (*R)+(*H)*(*R);
  /*   for (i=0; i<npts; i++) */
  /*     for (j=0; j<nvars; j++) */
  /*       results[i+j*npts]=(double)(resmat[i][j]); */
      
  /* Rprintf("%f %f %f %f\n",
   * resmat[0][0],resmat[0][1],resmat[1][0],resmat[1][1]); */
}

int gibbs(int H, int R, float a, long startiter, long maxiter,
	  int * poolsamp, irhmat rooksamp, int startfval, int thin,
	  frvec fprior, double * results,
	  int outfile, char * outfn, int from_R, int rptiter,
          int contrun, frvec startcontrib, frhmat startrookfreq) {

  float tmptot;

  int r,h,w0,w1,c;
  float sum;
  float totpool;
  float harmn;
  long it;
  char tmpbuf[1000];
  FILE * botfile, * frqfile;
  int print_out=FALSE;
  int save_out=TRUE;
  int badflag;
  
  long npts;

  frhmat rookprior,  /* prior (Dirichlet) parameters for rookery haplotype freqs */
    rookfreqval,     /* current Gibbs sample of rookery haplotype freqs */
    rooktot2;        /* total Gibbs sample+prior+real sample rook-hap estimates */
  irvec rooktot;     /* total sample size for each rookery */
/*   frvec fval;         *//* current Gibbs sample for rookery contributions */
  float fval[MAXROOK]; /* test of funny display in gdb */
  fhvec ybar;        /* average overall haplotype freqs in rookery samples */
  fhvec poolfreq;    /* current computed Gibbs sample for pool haplotype freqs */
  fhrmat w;          /* temporary (transposed) Gibbs prob. that indiv with hap H comes from rookery R */
  ihrmat tmpmat;     /* Gibbs sample of numbers of each hap from each rookery */
  frvec rookcontrib, /* total (Gibbs) contribution of each rookery */
    rooktotp;        /* Gibbs contr + prior for rookery contribs */


  if (outfile>0) {
     print_out=TRUE;
     save_out=FALSE;
     /* open output files */
     strncpy(tmpbuf,outfn,100);
     strncat(tmpbuf,".bot",4);
     botfile = fopen(tmpbuf,"w"); 
     strncpy(tmpbuf,outfn,100);
     strncat(tmpbuf,".frq",4);
     frqfile = fopen(tmpbuf,"w"); 
  }
     
  if (H>MAXHAP) {
    Rprintf("# haplotypes (%d) exceeds maximum (%ld)\n",H,MAXHAP);
    return(1);
  }
  if (R>MAXROOK) {
    Rprintf("# rookeries (%d) exceeds maximum (%ld)\n",R,MAXROOK);
    return(1);
  }
  for (r=0; r<R; r++) {
    for (rooktot[r]=0, h=0; h<H; h++)
      rooktot[r] += rooksamp[r][h];
    if (rooktot[r]==0) {
      Rprintf("Can't do Gibbs with all-missing loci ...\n");
      return(2);
    }
  }
  for (h=0, totpool=0.0; h<H; h++)
    totpool += poolsamp[h];
  /*  calculate prior according to Pella and Masuda from harmonic mean:
      a parameter scales the strength of the prior */
  for (r=0, sum=0; r<R; r++) {
    sum += (float)1/rooktot[r];
  }
  harmn = 1/(sum/R);
  for (h=0; h<H; h++) {
    for (r=0,ybar[h]=0.0; r<R; r++)
      ybar[h] += (float)rooksamp[r][h]/rooktot[r];
    ybar[h] /= R;
  }
  for(h=0; h<H; h++)
    for (r=0; r<R; r++)
      rookprior[r][h] =  a*sqrt(harmn)*ybar[h];
/*   if (fprior==NULL) { */
/*     Rprintf("allocating fprior\n"); */
/*     fprior = farray(R); */
    /** default prior for contributions is EQUAL contrib from all rooks **/
  if (fprior[0]<0)
    for (r=0; r<R; r++)
      fprior[r]=(float)1/R;
  /* } */
  /* allocate results matrix if necessary */
  npts = (maxiter-startiter)/thin;
  if (!from_R && outfile<=0) {
    results = (double *)calloc(npts*(R+H*R),sizeof(double));
    Rprintf("Allocating space: from_R=%d\n",from_R);
  }
    /*     results = fmatrix((maxiter-startiter)/thin,R+H*R); */
    /*  dimnames(results) <- list(NULL,
	c(paste("contrib",dimnames(rooksamp)$rookery,sep="."),
	outer(1:H,1:R,function(x,y)paste("rookhap",dimnames(rooksamp)$rookery[y],
	dimnames(rooksamp)$haplotype[x],sep="."))))
    */
  if (contrun==1) { /* continuation run; set fval and rookfreq directly */
     Rprintf("continuation run\n");
     for (r=0; r<R; r++) {
       fval[r]=startcontrib[r];
       for (h=0; h<H; h++)
          rookfreqval[r][h]=startrookfreq[r][h];
    }
  } else {
    /* set initial rookery freqs */
    for (r=0; r<R; r++)
      frdirich(&(rookprior[r][0]),H,&(rookfreqval[r][0]));
    /*      Rprintf("\nrookprior:\n"); */
    /*      for (r=0; r<R; r++) { */
    /*        for (h=0; h<H; h++) */
    /*  	Rprintf("%f ",rookprior[r][h]); */
    /*        Rprintf("\n"); */
    /*      } */
    /*      Rprintf("\nINITIAL rookfreqval:\n"); */
    /*      for (r=0; r<R; r++) { */
    /*        for (h=0; h<H; h++) */
    /*  	Rprintf("%g ",rookfreqval[r][h]); */
    /*      Rprintf("\n"); */
    /* set initial contributions */
    if (startfval<0)  /* ## use random start */
      frdirich(&(fprior[0]),R,&(fval[0]));
    else if (startfval==0)  /* equal-contribution start */
      for (r=0; r<R; r++)
	fval[r]=(float)1/R;
    else if (startfval<=R) {  /* start with 95% in one rookery,
			       * the rest evenly divided */
      for (r=0; r<R; r++) {
	if (r==startfval)
	  fval[r]=0.95;
	else
	  fval[r]=0.05/(R-1);
      }
    }
    else {
      Rprintf("startfval must be between 0 and R\n");
      return(3);
    }
  } /* if not contrun */
    /* pool contribs (f): vector, length R
     * rook haplotype freqs (h): matrix,
     *      H rows (haplotypes) x R cols (rookeries)
     * pool freqs (pool.freq): h %*% f, vector, length R
     * "val" indicates realized (Gibbs-sampler) value as
     * opposed to Dirichlet params
     */
    for (it=0; it<maxiter; it++) {
      if (rptiter>0 && it % rptiter==0)
	Rprintf("it. %ld\n",it);
      for (h=0; h<H; h++) poolfreq[h]=0.0;
      for (h=0; h<H; h++)
	/* total expected frequency in mixed population  */
	for (r=0; r<R; r++)
	  poolfreq[h]+=rookfreqval[r][h]*fval[r];
      /* probability that an individual with hap H (row) comes
       * from rookery R (column);
       * use R's "columns first" rule to calculate */
      badflag=FALSE;
      for (h=0; h<H; h++)
	for (r=0; r<R; r++) {
	  if (rookfreqval[r][h]==0 && poolfreq[h]==0) {
	    Rprintf("flagged w[%d,%d]\n",r,h);
	    w[h][r] = 0.0; badflag=TRUE;
	  }
	  else
	    w[h][r] = rookfreqval[r][h]*fval[r]/poolfreq[h];
	}
      /*     ## take multinomial samples of each type ... */
      for (h=0; h<H; h++)
	/* 	genmul(poolsamp[h],&(w[h][0]),H,&(tmpmat[h][0])); */
	/*** DUMB DUMB DUMB DUMB! fixed bug -- was "H" instead of "R" for
	 *** number of categories  ... ***/
	fgenmul(poolsamp[h],&(w[h][0]),R,&(tmpmat[h][0]),TRUE);
	/*  get posteriors for p (pool contribs, f) and Q
	 * (rook freqs, rookfreq) 
	 * supposing we're doing things the easy way: 
	 * posterior of p =  (pool sample plus any priors if desired)
	 * rookcontrib <- apply(tmpmat,2,sum) */
      for (h=0; h<H; h++)
	for (r=0; r<R; r++) 
	  if (tmpmat[h][r]<0) {
	    Rprintf("flagged tmpmat[%d,%d]\n",h,r);
	    badflag=TRUE;
	  }
      if (badflag) {
	Rprintf("\npoolsamp: ");
	for (h=0; h<H; h++)
	      Rprintf("%d ",poolsamp[h]);
	Rprintf("\nw:\n");
	for (h=0; h<H; h++) {
	  for (r=0; r<R; r++)
	    Rprintf("%f ",w[h][r]);
	  Rprintf("\n");
	}
	Rprintf("\ntmpmat:\n");
	for (h=0; h<H; h++) {
	  for (r=0; r<R; r++)
	    Rprintf("%d ",tmpmat[h][r]);
	  Rprintf("\n");
	}
	Rprintf("\nrookfreqval:\n");
	for (r=0; r<R; r++) {
	  for (h=0; h<H; h++)
	    Rprintf("%f ",rookfreqval[r][h]);
	  Rprintf("\n");
	}
	Rprintf("\nfval:\n");
	for (r=0; r<R; r++)
	  Rprintf("%f ",fval[r]);
	Rprintf("\npoolfreq:\n");
	for (h=0; h<H; h++)
	  Rprintf("%f ",poolfreq[h]);
	Rprintf("\n");
      }
      for (r=0; r<R; r++) rookcontrib[r]=0.0;
      for (h=0; h<H; h++)
	for (r=0; r<R; r++)
	  rookcontrib[r] += tmpmat[h][r];
      for (r=0; r<R; r++) {
	rooktotp[r] = rookcontrib[r]+fprior[r];
	if (rooktotp[r]<0) Rprintf("rooktotp<0\n");
      }
      frdirich(&(rooktotp[0]),R,&(fval[0]));
      /* posterior of Q = (rookery sample + pool sample (known) + priors) */
      for (r=0; r<R; r++) {
	for (h=0; h<H; h++)
	  rooktot2[r][h] = rooksamp[r][h]+tmpmat[h][r]+rookprior[r][h];
	frdirich(&(rooktot2[r][0]),H,&(rookfreqval[r][0]));
      }
      if (it>=startiter) {
	w0 = it-startiter;
	if (w0 % thin == 0) {
	  w1 = w0 / thin;
          if (print_out) {
  	     for (r=0; r<R; r++)
	        fprintf(botfile,"%1.10g ",fval[r]);
             fprintf(botfile,"\n");
	      for (r=0; r<R; r++)
	        for (h=0; h<H; h++)
	           fprintf(frqfile,"%1.10g ",rookfreqval[r][h]);
             fprintf(frqfile,"\n");
          } /* print output */
          if (save_out) {
  	     for (r=0; r<R; r++)
	        results[w1+r*npts] = (double)fval[r];
	      for (r=0; r<R; r++)
	        for (h=0; h<H; h++)
	           results[w1+(R+r*H+h)*npts] = (double)rookfreqval[r][h];
	  } /* save output */
	}  /* if thin */
      }  /* if beyond burn-in */
    } /* main Gibbs iteration loop */
    /* if (outfile) {
       Rprintf("check BUGS output file -- not tested since changes\n");
       BUGSout(results,H,R,(maxiter-startiter)/thin,outfn);
       } */
    if (print_out) {
      fclose(botfile);
      fclose(frqfile);
    }
    return(0);
}


void BUGSout(double * g, int H, int R, long tot, char *fn) {
  /*   ## take a gibbs run (nxp dataframe) and output to files in BUGS/CODA-compatible format */
  FILE *ind, *out;
  int p;
  int i;
  long j;

  ind=tryfile(fn,".ind",1,1);
  out=tryfile(fn,".out",1,2);

  p = R+H*R; /* number of columns */

  for (i=0; i<p; i++) {
    fprintf(ind,"var%d %ld %ld\n",i+1,i*tot+1,(i+1)*tot);
    for (j=0; j<tot; j++)
      fprintf(out,"%ld %f\n",j+1,g[j+i*tot]);
  }
  return;
}
@


1.12
log
@changed fprintf to Rprintf;
added capability for continuation runs (contrun, contrib start, rookfreq start
 parameters) to gibbswrap/gibbs
@
text
@d4 1
a4 1
#include "randlib.h"
a5 1
#include "vecutils.h"
d9 3
a11 3
#define MXNCAT 100L
#define MAXHAP  MXNCAT
#define MAXROOK MXNCAT
d19 1
a19 1
typedef long   ihrmat[MAXHAP][MAXROOK];
d24 2
a25 1
extern void rdirich(float *prob, int ncat, float *results);
d69 2
a70 2
  phrtsd(phrase,&is1,&is2);
  setall(is1,is2);
d118 2
a119 2
  is1 = (long)ranseed;
  setall(is1,is2);
d147 1
a147 2
         scontrib,srookfreq);

a163 2
  static float genmul_kluge=0.9999F;
  int genmul_flag=0;
d175 1
d248 1
a248 1
    results = darray(npts*(R+H*R));
d258 1
d265 1
a265 6
    /*   # set initial rookery freqs */
  for (r=0; r<R; r++)
    rdirich(rookprior[r],H,rookfreqval[r]);
  if (startfval<0)  /* ## use random start */
    rdirich(fprior,R,fval);
  else if (startfval==0)  /* ## equal-contribution start */
d267 20
a286 2
      fval[r]=(float)1/R;
    else if (startfval<=R) {  /* ## start with 95% in one rookery, the rest evenly divided */
d299 7
a305 5
    /*   ## pool contribs (f): vector, length R
	 ## rook haplotype freqs (h): matrix, H rows (haplotypes) x R cols (rookeries)
	 ## pool freqs (pool.freq): h %*% f, vector, length R
	 ## "val" indicates realized (Gibbs-sampler) value as opposed to Dirichlet params
    */
d311 1
d314 4
a317 2
      /*  ## probability that an individual with hap H (row) comes from rookery R (column);
	  ## use R's "columns first" rule to calculate */
d319 7
a325 14
	for (r=0; r<R; r++)
	  w[h][r] = rookfreqval[r][h]*fval[r]/poolfreq[h];
      /** genmul KLUGE: complains if sum(prob) > 0.99999 **/
      /* genmul_flag=0;
	 for (h=0; h<H; h++) {
	for (r=0,tmptot=0; r<R; r++)
	  tmptot += w[h][r];
	if (tmptot>genmul_kluge) {
	  genmul_flag=1;
	  if (tmptot>1.01) 
	    Rprintf("weird gibbs sum>1 (%f): adjusting down by %f\n",
		    tmptot,genmul_kluge/tmptot);
	  for (r=0; r<R; r++)
	    w[h][r] *= genmul_kluge/tmptot;
a326 2
	}*/
	  
d332 42
a373 5
	genmul(poolsamp[h],&(w[h][0]),R,&(tmpmat[h][0]));
	/*     ## get posteriors for p (pool contribs, f) and Q (rook freqs, rookfreq) */
	/*     ## supposing we're doing things the easy way: */
	/*     ## posterior of p =  (pool sample plus any priors if desired) */
	/*     rookcontrib <- apply(tmpmat,2,sum) */
d378 1
a378 1
      for (r=0; r<R; r++)
d380 4
a383 2
      rdirich(rooktotp,R,fval);
      /*     ## posterior of Q = (rookery sample + pool sample (known) + priors) */
d387 1
a387 1
	rdirich(rooktot2[r],H,rookfreqval[r]);
@


1.11
log
@long blank do not remember...
@
text
@d7 1
d34 4
a37 1
	       int *rptiter);
d42 2
a43 1
	  int outfile, char *outfn, int from_R, int rptiter);
d56 2
a57 1
  frvec fprior;
d88 1
a88 1
	1,"turtle-gibbs",FALSE,rptiter);
d99 4
a102 1
	       int *rptiter) {
d107 1
d109 1
d115 1
d121 1
a121 1
  /*   fprintf(stderr,"PRNG seed: (%s) %ld %ld\n",*randphrase,is1,is2); */
d123 1
a123 1
   * fprintf(stderr,"Printing output to file %s.{BOT,FRQ}\n",outfn[0]);
d127 7
a133 3
  for (h=0; h<(*H); h++) 
    for (r=0; r<(*R); r++)
      rookmat[r][h] = rooksamp[(*H)*r+h];
d138 1
a138 1
  /*     fprintf(stderr,"allocating fprior\n"); */
d146 2
a147 1
	*outfile,*outfn,TRUE,*rptiter);
d155 1
a155 1
  /* fprintf(stderr,"%f %f %f %f\n",
d162 2
a163 1
	  int outfile, char * outfn, int from_R, int rptiter) {
d169 1
a169 1
  int r,h,w0,w1;
d208 1
a208 1
    fprintf(stderr,"# haplotypes (%d) exceeds maximum (%ld)\n",H,MAXHAP);
d212 1
a212 1
    fprintf(stderr,"# rookeries (%d) exceeds maximum (%ld)\n",R,MAXROOK);
d219 1
a219 1
      fprintf(stderr,"Can't do Gibbs with all-missing loci ...\n");
d240 1
a240 1
/*     fprintf(stderr,"allocating fprior\n"); */
d251 1
a251 1
    fprintf(stderr,"Allocating space: from_R=%d\n",from_R);
d259 7
d283 1
a283 1
      fprintf(stderr,"startfval must be between 0 and R\n");
d286 1
d294 1
a294 1
	fprintf(stderr,"it. %ld\n",it);
d312 1
a312 1
	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n",
d366 1
a366 1
       fprintf(stderr,"check BUGS output file -- not tested since changes\n");
@


1.10
log
@fixing [3~ normalized fprior submitted to w
@
text
@d150 1
a150 1
  float totprior=0.0;
a159 1
  float minhap=1e-7;
d212 1
a212 2
  harmn = 1/(sum/(float)R);
  /* printf("harmn %f\n",harmn); */
d219 1
a219 1
    for (r=0; r<R; r++) {
d221 4
a224 7
      /* printf("rookprior %d %d %f\n",r,h,rookprior[r][h]); */
      /* printf("a sqrt(harmn) ybar[h] %f %f %f\n",a,sqrt(harmn),ybar[h]); */
    }
  /*   if (fprior==NULL) { */
  /*     fprintf(stderr,"allocating fprior\n"); */
  /*     fprior = farray(R); */
  /** default prior for contributions is EQUAL contrib from all rooks **/
a274 3
      for(r=0; r<R; r++)
	totprior += fprior[r];
  
d276 2
a277 6
	for (r=0; r<R; r++) {
	  if (poolfreq[h]>minhap)
	    w[h][r] = rookfreqval[r][h]*fval[r]/poolfreq[h];
	  else
	    w[h][r] = fprior[r]/totprior;
	}
d279 2
a280 2
       genmul_flag=0;
      for (h=0; h<H; h++) {
d283 1
a283 1
	if (tmptot> genmul_kluge) {
d291 1
a291 1
      } 
@


1.9
log
@putting all back to the original state but the warning for the prior that does not add up to one is suppressed
@
text
@d150 1
a150 1

d280 3
d288 1
a288 1
	    w[h][r] = fprior[r];
d297 3
a299 3
/*  	  if (tmptot>1.01)  */
/*  	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n", */
/*  		    tmptot,genmul_kluge/tmptot); */
@


1.8
log
@struggling more
@
text
@d160 1
d213 2
a214 1
  harmn = 1/(sum/R);
d221 1
a221 1
    for (r=0; r<R; r++)
d223 7
a229 4
/*   if (fprior==NULL) { */
/*     fprintf(stderr,"allocating fprior\n"); */
/*     fprior = farray(R); */
    /** default prior for contributions is EQUAL contrib from all rooks **/
d281 6
a286 2
	for (r=0; r<R; r++)
	  w[h][r] = rookfreqval[r][h]*fval[r]/poolfreq[h];
d289 1
a289 1
	 for (h=0; h<H; h++) {
d292 1
a292 1
	if (tmptot>genmul_kluge) {
d294 3
a296 3
	  if (tmptot>1.01) 
	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n",
		    tmptot,genmul_kluge/tmptot);
d300 1
a300 1
	}
@


1.7
log
@struggling
@
text
@a146 4
<<<<<<< turtle-gibbs.c
<<<<<<< turtle-gibbs.c
  static int genmul_kluge=99999;
=======
a147 4
>>>>>>> 1.3
=======
  static float genmul_kluge=0.9999F;
>>>>>>> 1.3
a278 15
<<<<<<< turtle-gibbs.c
       genmul_flag=0;
/*  	 for (h=0; h<H; h++) { */
/*  	for (r=0,tmptot=0; r<R; r++) */
/*  	  tmptot += w[h][r]; */
/*  	if (tmptot>genmul_kluge) { */
/*  	  genmul_flag=1; */
/*  	  if (tmptot>1.01)  */
/*  	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n", */
/*  		    tmptot,genmul_kluge/tmptot); */
/*  	  for (r=0; r<R; r++) */
/*  	    w[h][r] *= genmul_kluge/tmptot; */
/*  	} */
/*  	} */
=======
a291 1
>>>>>>> 1.6
@


1.6
log
@puttting it back.
@
text
@d147 4
d152 4
d287 15
d315 1
@


1.5
log
@another attempt...
@
text
@d147 1
a147 1
  static int genmul_kluge=99999;
@


1.4
log
@another attempt
@
text
@d147 1
a147 1
  static float genmul_kluge=99999;
@


1.3
log
@another attempt top[3~[3~[3~[3~[3~[3~[3~[3~
modify the constraints
@
text
@d147 1
a147 1
  static float genmul_kluge=0.9999F;
d280 12
a291 12
/*  	 for (h=0; h<H; h++) { */
/*  	for (r=0,tmptot=0; r<R; r++) */
/*  	  tmptot += w[h][r]; */
/*  	if (tmptot>genmul_kluge) { */
/*  	  genmul_flag=1; */
/*  	  if (tmptot>1.01)  */
/*  	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n", */
/*  		    tmptot,genmul_kluge/tmptot); */
/*  	  for (r=0; r<R; r++) */
/*  	    w[h][r] *= genmul_kluge/tmptot; */
/*  	} */
/*  	} */
@


1.2
log
@trying to modify the summation constraint.
@
text
@d279 13
a291 13
      /* genmul_flag=0;
	 for (h=0; h<H; h++) {
	for (r=0,tmptot=0; r<R; r++)
	  tmptot += w[h][r];
	if (tmptot>genmul_kluge) {
	  genmul_flag=1;
	  if (tmptot>1.01) 
	    fprintf(stderr,"weird gibbs sum>1 (%f): adjusting down by %f\n",
		    tmptot,genmul_kluge/tmptot);
	  for (r=0; r<R; r++)
	    w[h][r] *= genmul_kluge/tmptot;
	}
	}*/
@


1.1
log
@Initial revision
@
text
@d279 2
a280 2
      genmul_flag=0;
      for (h=0; h<H; h++) {
d291 1
a291 1
      }
@
